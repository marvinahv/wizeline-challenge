- installed rbenv to manage ruby versions
- installed ruby 3.2.7 using rbenv
- set ruby 3.2.7 as local version for the project
- installed rails 8.0.2
- created a new rails 8 API application with PostgreSQL and Minitest
- configured git username and email
- configured database connection to PostgreSQL
- created development and test databases
- given the requirements don't specify signup functionality, we are only focusing on the authentication part. but want to aknowledge futher functionality could be. for this implementation we will assume that they have already signed up and/or joined a project
    - admin can signup with name, email, and password
    - admin can confirm account via magic link on email
    - admin can invite manager to project with name and email
    - admin can invite developer to project with name and email
    - manager can join project via magic link on email
    - manager can be automatically signed up via magic link
    - developer can join project via magic link on email
    - developer can be automatically signed up via magic link
- we will also aknowledge there could be more functionality for asigning roles to users, but for the scope of thir project that functionality won't be included either
- added bcrypt and JWT gems for authentication
- added FactoryBot for test factories
- wrote User model tests with validation and authentication tests using TDD approach
- implemented User model with validations for name, email, password, and role
- implemented JWT token generation for authentication
- all User model tests passing
- enhanced password security with stronger requirements:
  - minimum 8 characters
  - must contain at least one uppercase letter
  - must contain at least one lowercase letter
  - must contain at least one number
  - must contain at least one special character
- created API structure with versioning (v1)
- implemented BaseController with authentication helpers
- implemented AuthenticationController with login endpoint
- all authentication controller tests passing
- given these features are not explicitely defined, we are seeting these rules so we can fulfill the requirements in way that makes sense but with a scope limit given the time constraints:
    - projects can only be created by an admin user
    - projects must have a unique name
    - projects must have a project manager user assigned
    - only the admin who created a project can edit its name
    - only the admin who created a project can assign it to a different manager
    - 
- wrote Project model tests with validation and association tests using TDD approach
- implemented Project model with:
  - validation to ensure only admin users can own projects
  - validation to ensure only project managers can manage projects
  - all Project model tests passing
- refactored permission logic:
  - removed direct permission methods from Project model
  - implemented authorization using CanCanCan gem
  - updated Project model tests to verify permissions through CanCanCan's ability system
  - implemented Ability class with role-based permissions:
    - everyone can read projects
    - admin users can create projects
    - admin users can update, change name, and change manager only for projects they own
    - project managers can manage tasks for projects they manage
- decided on task rules:
  - tasks belong to a project
  - tasks can only be created by the project's manager
  - tasks must have a description (no separate title field)
  - tasks must have an assigned developer
  - tasks must have a status (todo, in_progress, done)
  - tasks default to "todo" status when created
  - only the assigned developer can change the status of a task
- implemented Task model with TDD approach:
  - created task model tests for validations and associations
  - implemented Task model with required validations and associations
  - added status validation and default status functionality
  - extended Ability class to include task-related permissions:
    - project managers can create, update, and delete tasks for projects they manage
    - project managers cannot update task status
    - developers can view tasks in projects they're assigned to
    - only assigned developers can update status of tasks assigned to them
- implemented controller tests for proper separation of concerns:
  - separated model tests from authorization tests
  - created focused controller tests for projects that verify:
    - only admins can create new projects
    - only the admin that created a project can update its name
    - only the admin that created a project can reassign its manager
  - created focused controller tests for tasks that verify:
    - only project managers can create tasks for their projects
    - only the assigned developer can update a task's status
    - project managers can update task description and assignee
- implemented controllers with proper authorization:
  - created ProjectsController with CRUD operations
  - created TasksController with CRUD operations plus status updates
  - used CanCanCan load_and_authorize_resource for authorization
  - added nested routes for project tasks
  - implemented a custom route for task status updates
- added project deletion authorization and cascading deletes:
  - implemented ability rule to ensure only admin owners can delete their projects
  - verified that projects delete their associated tasks when removed (using dependent: :destroy)
  - added tests to verify both behaviors
- added functionality so only assigned manager can delete project tasks
- confirmed all required API endpoints are implemented:
  - Projects CRUD operations:
    - Create: POST /api/v1/projects
    - Read: GET /api/v1/projects and GET /api/v1/projects/:id
    - Update: PUT /api/v1/projects/:id
    - Delete: DELETE /api/v1/projects/:id
  - Tasks CRUD operations:
    - Create: POST /api/v1/projects/:project_id/tasks
    - Read: GET /api/v1/projects/:project_id/tasks and GET /api/v1/tasks/:id
    - Update: PUT /api/v1/tasks/:id
    - Delete: DELETE /api/v1/tasks/:id
  - Task status updates:
    - Update status: PUT /api/v1/tasks/:id/status
- implemented user-specific project views with default sorting:
  - admins see only their created projects, sorted by creation date (newest first)
  - project managers see only projects they manage, sorted by creation date (newest first)
  - developers see only projects where they have assigned tasks, sorted by creation date (newest first)
- implemented role-based task listing with default sorting:
  - project managers can see all tasks for projects they manage, sorted by creation date (oldest first)
  - developers can only see tasks assigned to them, sorted by creation date (oldest first)
  - security enhancements ensure other managers cannot see tasks for projects they don't manage
- implemented GitHub integration with Personal Access Tokens (PATs):
  - added github_token field to User model with built-in Rails encryption
  - configured ActiveRecord::Encryption for secure token storage
  - added github_connected? helper method to check if a user has connected their GitHub account
  - added comprehensive tests for GitHub token functionality:
    - tests for the github_connected? method
    - tests to verify token encryption is working correctly
  - chose PAT approach for simplicity and security in the API-only application
  - the requirements say authenticated users should be able to use the github api to get and display data; so we are assuming there already exists a mechanism for requesting, granting, and storing the github token for time's sake
  - in a real-life production implementation, we would include:
    - proper OAuth 2.0 integration flow with GitHub:
      - implementation of authorization request endpoint (/auth/github)
      - GitHub callback endpoint to handle authorization code exchange
      - token refresh mechanisms for OAuth tokens with expiration
    - secure token management:
      - automatic token refresh before expiration
      - token revocation when users disconnect their GitHub account
      - handling GitHub API rate limits with appropriate backoff strategies
    - user interface considerations:
      - clear connect/disconnect GitHub account options
      - transparency about what data is accessed and why
      - handling edge cases like token invalidation by the user on GitHub's side
    - advanced security measures:
      - token scope limitation to minimum required permissions
      - audit logging for all GitHub API access
      - regular security reviews of GitHub integration code
- I decided to use VCR for testing our Github service since I like it better than just mocking the API responses. We get real data. And I've worked with it in the past.
- implemented VCR for GitHub API testing:
  - added VCR and WebMock gems to the development and test environments
  - configured VCR in the test helper to record HTTP interactions for tests
  - set up security-focused filtering to ensure GitHub tokens are never recorded in cassettes
  - created a dedicated directory for VCR cassettes
  - updated user factory to include a GitHub token trait using TEST_USER_GITHUB_TOKEN environment variable
  - implemented GitHub service to securely handle token usage without exposing sensitive data in logs
  - created comprehensive tests for the GitHub service:
    - test for successfully fetching repository data
    - test for gracefully handling API errors when repositories don't exist
  - updated error handling in GitHub service to ensure tokens are never leaked in logs
  - verified that VCR cassettes were properly created with sensitive data filtered
- because of the time constraints and not being specified in the document, we are also assuming that a project is linked to a github repo. assuming there would be in a more robust solution:
  - an endpoint to add a github repo to a project
  - an endpoint to edit the repo of a project
  - an endpoint to remove a github repo from a project
  - etc